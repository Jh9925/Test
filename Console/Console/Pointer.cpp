#include<iostream>

using namespace std;

#pragma region 포인터
/*
▶ 포인터	Pointer

- 주소를 저장하는 변수
- 모든데이터는 메모리 상에 특정한 공간에 저장되어 있음
- 기존의 우리가 알고있는 변수는 데이터를 저장하지만 포인터는 메모리 공간의 주소를 저장한다.
- 포인터 변수가 주소를 저장하려면 변수의 주소를 알아야함.
	ㄴ 변수이름 앞에 &연산자를 붙이면 해당변수의 시작주소를 반환한다.
- 또한 포인터 변수가 저장하는 변수의 주소에 저장된 값을 참조하려면 *연산자를 사용한다.

- 포인터 변수는 8바이트 32비트 운영체제면 4바이트.

& : 특정한 데이터의 메모리상의 주소값을 알수있다.
* : &연산자가 어떤 데이터의 주소값을 얻어내는 연산자라면 주소값에서 해당 주소값에 대응되는 데이터를 가져온다.

int* p;   <-- 포인터 변수 p 선언 / 주소값만 저장할수 있음.


- 포인터 변수는 왜 타입이 있나?

- 포인터는 시작주소를 저장
- 얼마만큼 읽어야 하는지 알려주기 위해 타입이 존재한다.
*/
#pragma endregion

/*
const 붙이는 습관을 기르자.
포인터에도 붙일수 있다.


*/

int main()
{
	int* p;   // < --포인터 변수 p 선언 / 주소값만 저장할수 있음.
	
	int a = 2;
	p = &a;  //  변수 a의 주소를 저장.
	cout << "p의 값 (변수 a의 주소 값) : "<< p << endl;
	cout << a << endl;
	cout << "*p의 값 " << *p << endl;
	*p = 100;
	cout << "변경 후 *p의 값 " << *p << endl;


	// const double PI = 3.141592;


	//int num;
	//const int* pa = &num;
	/*
		const int형 변수를 가르킨다는것이 아니라 
		int형 변수를 가리키는데 그 값을 절대로 바꾸지 말라는 뜻
		즉, pa는 어떤 int형 변수를 가리키고 있고 const가 붙어있기 때문에
		pa가 가리키는 변수의 값은 절대로 바뀌면 안된다는 뜻이다.
	
		*pa = 3;  // X
		pa = &b;  // O
	
	
	- 주소를 상수화 하기
	int a;
	int b;
	int* const pa = &a;

	*pa = 3;  // O
	pa = &b;  // X
	위에서는 a의 주소를 저장
	pa는 절대적으로 바뀌면 안되지만 b의 주소를 담으려고 했기 때문에 XX



	*/




	return 0;
}