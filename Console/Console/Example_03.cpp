#include <iostream>
#include<algorithm>
#include<functional>

using namespace std;


#pragma region 연산자 + 반복문
/*

▶ 연산자란? 

- 프로그래밍 동작을 할떄 정해져있는 특정 역할을 수행하는 키워드를 연산자라고 할수있다.
ㄴ 연산자를 이용하면 다양한 프로그램 로직을 만들어 내는것이 가능하다.

▷ 기본적인 연산자의 종류

- 산술	( +, -, *, /, %)
- 비교	( ==, !=, <, >, <=, >=)
- 할당	(=, +=, -=, *=, /=, %=)
- 비트	(&, |, ^)
- 논리	(
- 형 변환



○ 비교

num == num2;		num 과 num2가 같다.
num != num2;		num 과 num2가 같지 않다.
num < num2;			num 과 num2가 작다.
num > num2;			num 과 num2가 크다.
num <= num2;		num 과 num2가 작거나 같다.
num >= num2;		num 과 num2가 크거나 같다.

● 할당

= 대입연산자 (우 -> 좌)
+=, -=, *=, /=, %=


● 비트 연산자 (비트와이즈)

- 메모리를 효율족 / 빠른 연산을 위해 사용한다.
ㄴ AND
ㄴ OR
ㄴ XOR
ㄴ NOT
ㄴ <<
ㄴ >>



● 논리 (bool)

bool num;
num				num이 만족하면 실행 (참)		
num && num2		num과 num2 의 조건이 둘다참 이면 실행 AND
num || num2		num과 num2 의 조건이 둘중 하나라도 참이면 실행 OR 
!num			num이 만족하지 않으면 실행 (논리 부정)



● 형 변환 연산자

-(( 특정 자료명)) 변수명

- C /C++ 언어는 형변환 연산자를 이용하면 간단하데 해당변수의 자료형을 변경하는것이 가능

● (강제) 형변환에 대해서

- C 스타일의 명시적 형변환은 가독성이 떨어지고 버그가 생길 여지는 만들고 시작한다.
ㄴ 그렇기 때문에 주의가 필요( 안정성 낮아짐)
	ㄴ 안정성을 우선시 할꺼면 캐스팅 연산자를 사용해야 한다.


	EX: static_cast<Data Type>(obj)
		ㄴ obj를 type으로 바꾼다.
		ㄴ 논리적으로 가능한 경우에만 변환 ( 안정성 올라감 )


		
		
★★★★★★★		
● C++ 스타일 형변환 연산자

- static_cast 
ㄴ 

- dynamic_cast
ㄴ 클래스

- const_cast
ㄴ 상수성을 제거하는 형 변환

- reinterpret_cast
ㄴ 포인터에 형변환



★★★★★★★

=================================================

▶ 반복문

- 프로그램의 특정부분을 일정횟수 이상 반복해서 실행하도록 하기위한 문법
ㄴ 반복문을 이용하면 반복적으로 발생되는 구간을 간단하게 / 효율적으로 처리하는것이 가능하다.


● C / C++ 언어의 표준 반복문

1. for


2. while 



3. do ! while
 


펄어비스 온라인 서술형
- 반복문은 과연 필수 문법일까?
- 효율적이지만 필수는 아니다. (최적화 문제)




*/




#pragma endregion

void main()
{
	int numberA = 0;

	numberA = 1;
	numberA++;
	numberA = 6;
	numberA++;
	numberA += 5;
	numberA--;
	numberA -= 2;
	numberA *= 3;
	numberA /= 2; 

	//?  13
	cout << "numberA 값: " << numberA << endl;
	
	/*
	C / C++ 언어는 연산자를 이용하여 결과를 만들어낼때 해당 연산자에 사용된 변수의 자료형의 따라
	결과가 달라진다.
	
	EX) 
	정수 + 실수 = 실수

	- 소실의 위험이 적은 자료형으로 만들어진다.

	- %는 정수형 데이터에만 쓸수있다.


	*/


	/*
	
	01. for 문

	- 구성 
	ㄴ 초기식 : 반복을 위한 변수의 선언및 초기화
	ㄴ 조건식 : 반복의 조건을 검사하는 목적으로 건언
	ㄴ 증감식 : 반복의 조건을 거짓으로 만드는 증가 및 감소 연산

	반복횟수가 정해진 반복에서 사용하면 좋다.

	EX) 
	 
	 for (초기식; 조건식; 증감식)
	 {
		반복이 되는 문장
		
	 }
	 
	 // 범위 기반 for문
	 // for문이 한번돌때마다 : 다음에 있는 녀석에 다음꺼 -> 다음꺼를 가져오고 n-1에 도달하면 종료
	 for (uActorComponent* Component : Component)
	 {
	 
	 
	 }


	 for each(auto p in vNumver)   // auto 자료형을 자동으로 받아오는
	 {
		cout << p << endl;

	 }

	 for_each(vNumber.begin(), vNumber.end(), [&Value](auto& number);
	 transform();





	
	*/


	// C스타일 (컴파일러 버전)

	int i;
	for (i = 0; i < 10; i++)
	{
		cout << "[" << i << " 번째]" << " 열심히 공부합시다." << endl;
	}
	
	// 짱짱맨을 고르시오
	//3
	cout << endl;
	//1
	cout << '\n';
	//2
	printf("\n \0");

	int numberB = 0;   // 초기식 생략시 0으로 인식 문법적으로
	for (; numberB < 5; numberB++)
	{
		cout << "이건... " << numberB << endl;
	}

	cout << endl;



	/*
	-위에 경우처럼 for문은 필요에 따라 초기식/ 조건식/ 증감식 생략이 가능하다.

	● 생략에 따른 유형

	1. 초기화 생략 -> for (; i < 10; i++)
	2. 조건식 생략 -> for (i = 0; ; i++)
	3. 초기화 증감식 생략 -> for (; i < 10;)
	4. 모두 생략 -> for (; ; )
	
	*/

	// 전위 / 후위

	// i++ / ++i

	int j = 1;
	for (int i= 0; i < 5; i++)
	{
		// 짝수형태로 두번씩 출력
		cout << "전" << ++j << endl; // 만나는 순간 메모리에 바로들어가서 계산
		cout << "후" << j++ << endl;	 // 뒤까지 다보고 세미콜론보고 계산

	}

	cout << endl;



	// 대부분의 반복문은 반복문 안에 반복문을 허용한다.
	// ㄴ 이를 중첩 반복문이라고 한다.
	// C 와 C++는 3중까지는 ok
	// 4중 부터는 정말 고민을 해보자.

	/*for (int i; i < 10; i++)
	{
		for (int i; i < 10; i++)
		{


		}

	}
	*/
	/*
	02. while 문

	- 무한 (loop)
	ㄴ 반복조건에 1이 들어갈경우 무한 루프에 빠지게 된다.
	ㄴ 이는 논리식으로 빠져나오거나 제어문을통해 강제로 탈출해야 한다.
	ㄴ 조건이 참(true)일때만 작동

	- while문은 특정조건을 주고 그 조건을 만족하는 동안 특정영역을 계속해서 반복하는 구조이다.
	
	
	*/

	/*int playerHp = 1000;

	while (playerHp > 0)
	{
		int hit = 100;
		playerHp -= hit;
		cout << "체력: " << playerHp << endl;
	}

	cout << '\n';

	int numC = 0;
	while (numC < 5)
	{
		cout << "이게 while문 이다." << endl;
		numC++;
 	}
	cout << '\n';*/

	/*
	03. do ~ while문

	- while문의 차이점: 조건을 검사하는 시점이 다름.

	- 일단 무조건 한번 실행을 하고 while문의 조건을 검사 -> 이후 do ~ while문안의 문장을 실행할것인지에 대해 판단한다.
	*/
	int numD;
	numD = 0;

	do
	{
		cout << "첫번째 do ~ while문" << endl;
		numD++;
	
	} while (numD < -1);


	do
	{
		cout << "2번째 do ~ while문" << endl;
		numD++;

	} while (numD < 3);

	int total = 0, num = 0;
	do
	{
		cout << "숫자입력(종료하고싶음 0 누르기)" << endl;
		cin >> num;
		total += num;
	} while (num != 0);

	cout << "입력한 숫자 합: " << total << endl;
	cout << endl;



}




/* 7_18
과제 1. 구구단 구현

-3종의 반복문을 이용해서 구구단 구현
ㄴ for / while / do ~ while
 
 for (int i = 2; i < 10; i++)
	{
		for (int j = 1; j < 10; j++)
		{


		}

	}

과제 2. 연산자 활용

-a. 두개의 정수를 받아서 두수의 덧샘과 뺄샘의 결과를 출력하는 프로그램 작성

-b. 3개의 정수 (num1, num2, num3)를 받아서 다음 연산의 결과를 출력하는 프로그램 작성
ㄴ EX (num1 + num2) * (num3 + num1) % num1 = ?

-c. 입력받은 두 정수를 나누었을때 얻게되는 몫과 나머지를 출력하는 프로그램 작성
ㄴ EX 7과 2입력 몫 3 나머지 1 출력
 

 과제 3. 반복문 출력

 -for / while / do ~ while문 모두 사용

 - 1부터 20까지 출력하시오.
 ㄴ 짝수만

 - 20에서 1까지 출력하시오.

 과제 4. 반복문 숙달. 4번에 가장 적합한거 하나 쓰기 이유도!

 - 정수 하나를 입력 받아 -5 씩 반복적으로 연산이 되는 식을 만든다.
 ㄴ 종료 조건 : -15 를 넘어가면 탈출
 ㄴ 조건 : 입력받는 값은 -10 ~ 10 사이에 숫자여야 하고 이외에 값을 입력시 프로그램 종료를 시킨다.

 ※ 조건식과 논리 연산자를 잘 보고 조건식을 만들어 반복문이 돌아가게 만드는것이 포인트

 과제 5. 별찍기

 - 본인이 판단한 효율적인 반복문 1종을 선택해서 사용할 것

 **						*
 ****				   **
 ******
 ********
 ********** 
 ********
 ******
 ****
 **
 

 도전과제1. 마름모 찍기  % 연산자 잘 써보기 (나머지)
 - 조건 for문 1번 + 1줄
 


 한줄조사 . 조건문

 - 노트에 적어온다.
 - 비유할것을 생각해온다. (Ex : 조건문은 000이다.)


*/